package ro.lbi.sqliggybank.server.Resources;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.exceptions.TokenExpiredException;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.dropwizard.hibernate.UnitOfWork;
import io.dropwizard.jersey.PATCH;
import ro.lbi.sqliggybank.server.Core.Group;
import ro.lbi.sqliggybank.server.Core.Invite;
import ro.lbi.sqliggybank.server.Core.User;
import ro.lbi.sqliggybank.server.Database.GroupDAO;
import ro.lbi.sqliggybank.server.Database.GroupListDAO;
import ro.lbi.sqliggybank.server.Database.UserDAO;
import ro.lbi.sqliggybank.server.Responses.*;

import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.UUID;

/**
 * GroupResource covers the groups endpoint for the SQLiggyBank API.
 *
 * It is in charge of getting and editing group information.
 *
 * Details for the implementation of these methods can be found in the
 * SQLiggyBank API Documentation.
 *
 * @author StormFireFox1
 * @since 2019-03-28
 * @see <a href="https://documenter.getpostman.com/view/3806934/RWgwRFa8?version=latest#715f219d-c1ee-482b-8996-15342e622cd2">SQLiggyBank API Documentation</a>
 */
@Path("/api/groups/")
@Produces(MediaType.APPLICATION_JSON)
public class GroupResource {
	/**
	 * groupDAO is the DAO for the "groups" table in the database.
	 *
	 * This is modified by the constructor.
	 */
	private final GroupDAO groupDAO;
	/**
	 * groupListDAO is the DAO for the "group_lists" table in the database.
	 *
	 * This is modified by the constructor.
	 */
	private final GroupListDAO groupListDAO;
	/**
	 * userDAO is the DAO for the "users" table in the database.
	 *
	 * This is modified by the constructor.
	 */
	private final UserDAO userDAO;
	/**
	 * authVerifier is the verifier for the HMAC256 algorithm used to sign
	 * JWT's.
	 */
	private final JWTVerifier authVerifier;

	/**
	 * The list of invites generated by the server.
	 *
	 * In order to invite a user into a group, they must generate an invite
	 * link to send to other users. These are ephemeral and only kept in the
	 * runtime of SQLiggyBank's server (don't persist after restart).
	 *
	 */	
	private final ArrayList<Invite> invites = new ArrayList<>();

	/**
	 * The constructor for GroupResource.
	 *
	 * The parameters should be passed solely by the ServerApplication
	 * class.
	 *
	 * @param groupDAO     The DAO to the "groups" table in the database.
	 * @param groupListDAO The DAO to the "group_lists" table in the
	 *                     database.
	 * @param userDAO      The DAO to the "users" table in the database.
	 * @param JWTSecret    The secret to be used for signing JWT's using the
	 *		       HMAC256 algorithm.
	 */
	public GroupResource(GroupDAO groupDAO, GroupListDAO groupListDAO, UserDAO userDAO, byte[] JWTSecret) {
		this.groupDAO = groupDAO;
		this.groupListDAO = groupListDAO;
		this.userDAO = userDAO;
		Algorithm authAlgorithm = Algorithm.HMAC256(JWTSecret);
		this.authVerifier = JWT.require(authAlgorithm)
				.withIssuer("SQLiggyBank")
				.build();
	}

	/**
	 * The endpoint for extracting group information.
	 *
	 * This endpoint, like almost all other endpoints in GroupResource,
	 * requires authentication.
	 *
	 * @param authorization The "Authorization" header of the HTTP request.
	 * @param groupName     The "groupName" parameter of the request. Passed
	 *			in the URL.
	 *
	 * @return A response according to the SQLiggyBank API Documentation. In
	 *         general, it returns a JSON object representing a Group.
	 * @see <a href="https://documenter.getpostman.com/view/3806934/RWgwRFa8?version=latest#6a45450f-edb9-473e-9ff2-e7c294cdd77d">API Documentation</a>
	 */
	@GET
	@UnitOfWork
	@Path("{groupName}")
	public Response getGroup(@HeaderParam("Authorization") String authorization, @PathParam("groupName") String groupName) {
		if (authorization != null) { // are they a user? Let's see if they pass the test.
			return findGroup(groupName, authorization);
		} else {
			return Response
					.status(Response.Status.FORBIDDEN)
					.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You must be logged in to view group information!"))
					.build();
		}
	}

	/**
	 * Finds a group, querying by its name. 
	 *
	 * This handles the logic behind the endpoint. It checks whether the
	 * user is a member of the group that they are querying for and returns
	 * the JSON representation of a Group object.
	 *
	 * @param groupName     The name of the group to find.
	 * @param authorization The "Authorization" header in the HTTP request.
	 *
	 * @return A response, depending on the query and errors. In general,
	 *         200 (OK) status code is returned if a group is found, and
	 *         404 (Not Found) status code is returned if a group cannot
	 *         be found in the database. If an authenticated user is not a
	 *         member of the group, they are restricted access using
	 *         a 403 (Forbidden) status code.
	 */
	private Response findGroup(String groupName, String authorization) {
		authorization = authorization.substring(authorization.indexOf(" ") + 1); // remove "Bearer" from Authorization header
		try {
			DecodedJWT jwt = authVerifier.verify(authorization); // verify token
			Group group = groupDAO.findByName(groupName).orElseThrow(() -> new NotFoundException("No such group."));
			if (groupListDAO.isUserPartOfGroup(jwt.getClaim("username").asString(), groupName)) { // user part of group, give group information
				return Response.ok(group).build();
			} else { // not part of group, eject client
				return Response
						.status(Response.Status.FORBIDDEN)
						.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You are not part of this group!"))
						.build();
			}
		} catch (TokenExpiredException e) {
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Token expired! Log in again!"))
					.build();
		} catch (JWTVerificationException e) { // invalid token, eject client
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Invalid authentication scheme!"))
					.build();
		} catch (NotFoundException e) {
			return Response
					.status(Response.Status.NOT_FOUND)
					.entity(new NotFoundResponse(groupName + " could not be found! Try again!"))
					.build();
		}
	}

	/**
	 * The endpoint for getting the invites of a group.
	 *
	 * This endpoint, like almost all other endpoints in GroupResource,
	 * requires authentication.
	 *
	 * @param authorization The "Authorization" header of the HTTP request.
	 * @param groupName     The "groupName" parameter of the request. Passed
	 *			in the URL.
	 *
	 * @return A response according to the SQLiggyBank API Documentation. In
	 *         general, it returns a JSON object representing an array of
	 *         Invites.
	 * @see <a href="https://documenter.getpostman.com/view/3806934/RWgwRFa8?version=latest#3736f9c1-830a-46a7-a69a-0dd0e5a145c7">API Documentation</a>
	 */
	@GET
	@UnitOfWork
	@Path("{groupName}/invites")
	public Response getInvites(@HeaderParam("Authorization") String authorization, @PathParam("groupName") String groupName) {
		if (authorization != null) { // get the invites
			return inviteList(authorization, groupName);
		} else { // if not owner, they can kiss the links goodbye
			return Response
					.status(Response.Status.FORBIDDEN)
					.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You must be logged in to view group information!"))
					.build();
		}
	}

	/**
	 * Finds the list of invites for a specific group. 
	 *
	 * This handles the logic behind the endpoint. It checks whether the
	 * user is the owner of the group that they are querying for and returns
	 * the JSON representation of an array of Invite objects.
	 *
	 * @param groupName     The name of the group to find invites for.
	 * @param authorization The "Authorization" header in the HTTP request.
	 *
	 * @return A response, depending on the query and errors. In general,
	 *         200 (OK) status code is returned if a group is found, and
	 *         404 (Not Found) status code is returned if a group cannot
	 *         be found in the database. If an authenticated user is not the
	 *         owner of the group, they are restricted access using
	 *         a 403 (Forbidden) status code.
	 */
	private Response inviteList(String authorization, String groupName) {
		authorization = authorization.substring(authorization.indexOf(" ") + 1); // remove "Bearer" from Authorization header
		try {
			DecodedJWT jwt = authVerifier.verify(authorization); // verify token
			Group group = groupDAO.findByName(groupName).orElseThrow(() -> new NotFoundException("No such group."));
			if (groupDAO.isUserOwnerOfGroup(jwt.getClaim("username").asString(), groupName)) { // user owner of group, give group invites
				ArrayList<Invite> groupInvites = new ArrayList<>();
				for (Invite invite :
						invites) {
					if (invite.getGroup().equals(groupName)) {
						groupInvites.add(invite);
					}
				}
				return Response.ok(groupInvites).build();
			} else { // not owner, eject client
				return Response
						.status(Response.Status.FORBIDDEN)
						.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You are not the owner of this group!"))
						.build();
			}
		} catch (TokenExpiredException e) {
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Token expired! Log in again!"))
					.build();
		} catch (JWTVerificationException e) { // invalid token, eject client
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Invalid authentication scheme!"))
					.build();
		} catch (NotFoundException e) {
			return Response
					.status(Response.Status.NOT_FOUND)
					.entity(new NotFoundResponse(groupName + "could not be found! Try again!"))
					.build();
		}
	}

	/**
	 * The endpoint for creating an invite.
	 *
	 * This endpoint, like almost all other endpoints in GroupResource,
	 * requires authentication.
	 *
	 * @param authorization The "Authorization" header of the HTTP request.
	 * @param groupName     The "groupName" parameter of the request. Passed
	 *			in the URL.
	 *
	 * @return A response according to the SQLiggyBank API Documentation. In
	 *         general, it returns a JSON object representing the new
	 *         Invite.
	 * @see <a href="https://documenter.getpostman.com/view/3806934/RWgwRFa8?version=latest#f7f9aff8-d042-4d51-b04a-620c2273e60e">API Documentation</a>
	 */
	@GET
	@UnitOfWork
	@Path("{groupName}/invites/new")
	public Response createInvite(@HeaderParam("Authorization") String authorization, @PathParam("groupName") String groupName) {
		if (authorization != null) { // get the invites
			return generateInviteLink(authorization, groupName);
		} else { // if not owner, they can kiss the links goodbye
			return Response
					.status(Response.Status.FORBIDDEN)
					.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You must be the group owner to generate invite links for this group!"))
					.build();
		}
	}

	/**
	 * Generates an invite link for a specific group. 
	 *
	 * This handles the logic behind the endpoint. It checks whether the
	 * user is the owner of the group that they are querying for and returns
	 * the JSON representation of a new Invite.
	 *
	 * @param groupName     The name of the group to find invites for.
	 * @param authorization The "Authorization" header in the HTTP request.
	 *
	 * @return A response, depending on the query and errors. In general,
	 *         200 (OK) status code is returned if a group is found, and
	 *         404 (Not Found) status code is returned if a group cannot
	 *         be found in the database. If an authenticated user is not the
	 *         owner of the group, they are restricted access using
	 *         a 403 (Forbidden) status code.
	 */
	private Response generateInviteLink(String authorization, String groupName) {
		authorization = authorization.substring(authorization.indexOf(" ") + 1); // remove "Bearer" from Authorization header
		try {
			DecodedJWT jwt = authVerifier.verify(authorization); // verify token
			Group group = groupDAO.findByName(groupName).orElseThrow(() -> new NotFoundException("No such group."));
			if (groupDAO.isUserOwnerOfGroup(jwt.getClaim("username").asString(), groupName)) { // user owner of group, give group invites
				Invite invite = new Invite(groupName, new Date());
				invites.add(invite);
				return Response
						.ok(invite)
						.build();
			} else { // not owner, eject client
				return Response
						.status(Response.Status.FORBIDDEN)
						.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You are not the owner of this group!"))
						.build();
			}
		} catch (TokenExpiredException e) {
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Token expired! Log in again!"))
					.build();
		} catch (JWTVerificationException e) { // invalid token, eject client
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Invalid authentication scheme!"))
					.build();
		} catch (NotFoundException e) {
			return Response
					.status(Response.Status.NOT_FOUND)
					.entity(new NotFoundResponse(groupName + "could not be found! Try again!"))
					.build();
		}
	}

	/**
	 * The endpoint for using an invite to join a group.
	 *
	 * This endpoint, like almost all other endpoints in GroupResource,
	 * requires authentication.
	 *
	 * @param authorization The "Authorization" header of the HTTP request.
	 * @param groupName     The "groupName" parameter of the request. Passed
	 *			in the URL.
	 * @param inviteUUID    The UUID of the invite to use. Passed in the
	 * 			URL.
	 *
	 * @return A response according to the SQLiggyBank API Documentation. In
	 *         general, it returns a JSON object relaying success.
	 * @see <a href="https://documenter.getpostman.com/view/3806934/RWgwRFa8?version=latest#77d62254-6326-4605-aac0-ff3a1bcc782d">API Documentation</a>
	 */
	@GET
	@UnitOfWork
	@Path("{groupName}/invite/{inviteID}")
	public Response groupInvite(@HeaderParam("Authorization") String authorization, @PathParam("groupName") String groupName, @PathParam("inviteID") String inviteUUID) {
		if (authorization != null) { // get the invites
			return addUserToGroup(authorization, groupName);
		} else { // if not owner, they can kiss the links goodbye
			return Response
					.status(Response.Status.FORBIDDEN)
					.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You must be logged in to accept invites!"))
					.build();
		}
	}

	/**
	 * The endpoint for creating a group. 
	 *
	 * This endpoint, like almost all other endpoints in GroupResource,
	 * requires authentication.
	 *
	 * @param authorization The "Authorization" header of the HTTP request.
	 * @param body          The JSON representation of the new Group object
	 *			to create.
	 *
	 * @return A response according to the SQLiggyBank API Documentation. In
	 *         general, it returns a JSON object relaying success.
	 * @see <a href="https://documenter.getpostman.com/view/3806934/RWgwRFa8?version=latest#c6f28eff-cebf-4948-8c18-bccadf554a26">API Documentation</a>
	 */
	@POST
	@UnitOfWork
	@Path("/new")
	public Response addGroup(@HeaderParam("Authorization") String authorization, String body) {
		if (authorization != null) { // let's create a group
			return createGroup(authorization, body);
		} else { // if not logged in, eject client
			return Response
					.status(Response.Status.FORBIDDEN)
					.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You must be the group owner to generate invite links for this group!"))
					.build();
		}
	}

	/**
	 * Creates a new group. 
	 *
	 * This handles the logic behind the endpoint. It creates a new group
	 * represented by the groupBody variable, and assigns the logged in
	 * user as its owner.
	 *
	 * @param authorization The "Authorization" header in the HTTP request.
	 * @param groupBody	The JSON representation of the Group object.
	 *
	 * @return A response, depending on the query and errors. In general,
	 *         200 (OK) status code is returned if a group is created, and
	 *         400 (Bad Request) status code is returned if the body is
	 *         unable to be parsed, or if it is malformed.
	 *         If a group with the provided name already exists, the client
	 *         is restricted access using a 403 (Forbidden) status code.
	 */
	private Response createGroup(String authorization, String groupBody) {
		authorization = authorization.substring(authorization.indexOf(" ") + 1); // remove "Bearer" from Authorization header
		try {
			DecodedJWT jwt = authVerifier.verify(authorization); // verify token
			User owner = userDAO.findByUsername(jwt.getClaim("username").asString()).orElseThrow(() -> new NotFoundException("User not found!"));
			Group tempGroup = new ObjectMapper().readValue(groupBody, Group.class); // create new Group object
			Group possibleGroup = groupDAO.findByName(tempGroup.getName()).orElse(null);
			if (possibleGroup != null) {
				return Response
					        .status(Response.Status.FORBIDDEN)
						.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "Group already exists, choose another name!"))
						.build();
			}
			if (tempGroup.getName() == null) {
				return Response
						.status(Response.Status.BAD_REQUEST)
						.entity(new GenericResponse(Response.Status.BAD_REQUEST.getStatusCode(), "Your submitted body is missing the \"name\" field, try again!"))
						.build();
			}
			tempGroup.setUuid(UUID.randomUUID()); // set random UUID, Hibernate needs it FeelsBadMan
			tempGroup.setOwner(owner);
			groupDAO.create(tempGroup);
			return addUserToGroup(authorization, tempGroup.getName());
		} catch (TokenExpiredException e) {
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Token expired! Log in again!"))
					.build();
		} catch (JWTVerificationException e) { // invalid token, eject client
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Invalid authentication scheme!"))
					.build();
		} catch (JsonParseException | JsonMappingException e) {
			return Response
					.status(Response.Status.BAD_REQUEST)
					.entity(new InternalErrorResponse(Response.Status.BAD_REQUEST.getStatusCode(), "Cannot parse submitted group body!", e.getMessage()))
					.build();
		} catch (IOException e) {
			return Response
					.status(Response.Status.INTERNAL_SERVER_ERROR)
					.entity(new InternalErrorResponse(e.getMessage()))
					.build();
		}
	}

	/**
	 * Adds a user to a group's member list. 
	 *
	 * This handles the logic behind the endpoint. It creates a new
	 * GroupEntry in the database, attached to the logged in user, and
	 * returns a standard response, equal to when creating a group.
	 *
	 * @param authorization The "Authorization" header in the HTTP request.
	 * @param groupName	The name of the group to add the user to.
	 *
	 * @return A response, depending on the query and errors. In general,
	 *         200 (OK) status code is returned if a group is joined, and
	 *         a 404 (Not Found) status code is returned if the group cannot
	 *         be found in the database. If a client is already part of the
	 *         provided group, they are restricted access using a 403
	 *         (Forbidden) status code.
	 */
	private Response addUserToGroup(String authorization, String groupName) {
		authorization = authorization.substring(authorization.indexOf(" ") + 1); // remove "Bearer" from Authorization header
		try {
			DecodedJWT jwt = authVerifier.verify(authorization); // verify token
			Group group = groupDAO.findByName(groupName).orElseThrow(() -> new NotFoundException("No such group."));
			if (!groupListDAO.isUserPartOfGroup(jwt.getClaim("username").asString(), groupName)) { // user not part of group, put them in
				groupListDAO.addUserToGroup(userDAO.findByUsername(jwt.getClaim("username").asString()).orElseThrow(() -> new NotFoundException("No user found!")), group);
				return Response
						.ok()
						.entity(new JoinedGroupResponse(new UUID(0,0)))
						.build();
			} else { // part of group, eject client
				return Response
						.status(Response.Status.FORBIDDEN)
						.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You are already part of this group!"))
						.build();
			}
		} catch (TokenExpiredException e) {
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Token expired! Log in again!"))
					.build();
		} catch (JWTVerificationException e) { // invalid token, eject client
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Invalid authentication scheme!"))
					.build();
		} catch (NotFoundException e) {
			return Response
					.status(Response.Status.NOT_FOUND)
					.entity(new NotFoundResponse(groupName + "could not be found! Try again!"))
					.build();
		}
	}

	/**
	 * The endpoint for editing group information.
	 *
	 * This endpoint, like almost all other endpoints in GroupResource,
	 * requires authentication.
	 *
	 * @param authorization The "Authorization" header of the HTTP request.
	 * @param groupName	The name of the group to edit. Passed in the
	 * 			URL.
	 * @param body		The JSON representation of the new Group object.
	 *
	 * @return A response according to the SQLiggyBank API Documentation. In
	 *         general, it returns a JSON object relaying success.
	 * @see <a href="https://documenter.getpostman.com/view/3806934/RWgwRFa8?version=latest#7d8ec62b-4748-4214-878c-16d5bf8f01c3">API Documentation</a>
	 */
	@PATCH
	@UnitOfWork
	@Path("{groupName}")
	public Response editGroupInfo(@HeaderParam("Authorization") String authorization, @PathParam("groupName") String groupName, String body) {
		if (authorization != null) { // get the invites
			return editGroup(authorization, groupName, body);
		} else { // if not owner, they can kiss the links goodbye
			return Response
					.status(Response.Status.FORBIDDEN)
					.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You must be the group owner to edit group information!"))
					.build();
		}
	}

	/**
	 * Edits a group's information. 
	 *
	 * This handles the logic behind the endpoint. It checks whether the
	 * logged in user is the owner of the group and edits the group by
	 * looking for elements in the body and replacing the overlapping
	 * elements. 
	 *
	 * @param authorization The "Authorization" header in the HTTP request.
	 * @param groupName	The name of the group to edit.
	 * @param newGroup	The JSON representation of the edited Group
	 * 			object.
	 *
	 * @return A response, depending on the query and errors. In general,
	 *         200 (OK) status code is returned if a group is edited, and
	 *         a 404 (Not Found) status code is returned if the group cannot
	 *         be found in the database. If a client is not the owner of the
	 *         group, they are restricted access using a 403 (Forbidden)
	 *         status code.
	 */
	private Response editGroup(String authorization, String groupName, String newGroup) {
		authorization = authorization.substring(authorization.indexOf(" ") + 1); // remove "Bearer" from Authorization header
		try {
			DecodedJWT jwt = authVerifier.verify(authorization); // verify token
			Group group = groupDAO.findByName(groupName).orElseThrow(() -> new NotFoundException("No such group."));
			User user = userDAO.findByUsername(jwt.getClaim("username").asString()).orElseThrow(() -> new NotFoundException("User not found!"));
			if (groupDAO.isUserOwnerOfGroup(jwt.getClaim("username").asString(), groupName)) { // are they ok?
				Group tempGroup = new ObjectMapper().readValue(newGroup, Group.class); // create new Group object
				// Apparently, Hibernate doesn't like you modifying the objects it remembers in memory, even if they
				// are functionally the same. In conclusion, crap code like this shows up, where I have to replace
				// everything in the original one.
				//
				// I'm just happy I don't have to make my own actual SQL queries :)
				if (tempGroup.getName() == null) {
					return Response
							.status(Response.Status.BAD_REQUEST)
							.entity(new GenericResponse(Response.Status.BAD_REQUEST.getStatusCode(), "Your submitted body is missing the \"name\" field, try again!"))
							.build();
				}
				Group possibleGroup = groupDAO.findByName(tempGroup.getName()).orElse(null);
				if (possibleGroup != null && !possibleGroup.getUuid().equals(group.getUuid())) {
					return Response
							.status(Response.Status.BAD_REQUEST)
							.entity(new GenericResponse(Response.Status.BAD_REQUEST.getStatusCode(), "Group already exists with this name! Try again."))
							.build();
				}
				group.setName(tempGroup.getName());
				group.setDescription(tempGroup.getDescription());
				group.setOwner(user);
				// update group
				groupDAO.update(group);
				return Response
						.ok(new GenericResponse(Response.Status.OK.getStatusCode(), "Update complete!"))
						.build();
			} else { // wrong user, eject client
				return Response
						.status(Response.Status.FORBIDDEN)
						.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You must be the group owner to edit this info!"))
						.build();
			}
		} catch (TokenExpiredException e) {
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Token expired! Log in again!"))
					.build();
		} catch (JWTVerificationException e) { // invalid token, eject client
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Invalid authentication scheme!"))
					.build();
		} catch (JsonParseException | JsonMappingException e) { // they screwed up the JSON for the group, eject them
			e.printStackTrace();
			return Response
					.status(Response.Status.BAD_REQUEST)
					.entity(new GenericResponse(Response.Status.BAD_REQUEST.getStatusCode(), "Invalid new group information! Try again!"))
					.build();
		} catch (IOException e) { // internal server error, apologize
			e.printStackTrace();
			return Response
					.serverError()
					.entity(new InternalErrorResponse("Could not access database!"))
					.build();
		} catch (NotFoundException e) {
			return Response
					.status(Response.Status.NOT_FOUND)
					.entity(new NotFoundResponse(groupName + "could not be found! Try again!"))
					.build();
		}
	}

	/**
	 * The endpoint for deleting a group.
	 *
	 * This endpoint, like almost all other endpoints in GroupResource,
	 * requires authentication.
	 *
	 * @param authorization The "Authorization" header of the HTTP request.
	 * @param groupName	The name of the group to delete. Passed in the
	 * 			URL.
	 *
	 * @return A response according to the SQLiggyBank API Documentation. In
	 *         general, it returns a JSON object representing a Group.
	 * @see <a href="https://documenter.getpostman.com/view/3806934/RWgwRFa8?version=latest#eca85721-9174-4f65-94f9-f2a1f606076b">API Documentation</a>
	 */
	@DELETE
	@UnitOfWork
	@Path("{groupName}")
	public Response deleteGroup(@HeaderParam("Authorization") String authorization, @PathParam("groupName") String groupName) {
		if (authorization != null) { // get the invites
			return removeGroup(authorization, groupName);
		} else { // if not owner, they can kiss the links goodbye
			return Response
					.status(Response.Status.FORBIDDEN)
					.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You must be the group owner to delete this group!"))
					.build();
		}
	}

	/**
	 * Deletes a group. 
	 *
	 * This handles the logic behind the endpoint. It checks whether the
	 * logged in user is the owner of the group and deletes the group. 
	 *
	 * @param authorization The "Authorization" header in the HTTP request.
	 * @param groupName	The name of the group to delete.
	 *
	 * @return A response, depending on the query and errors. In general,
	 *         200 (OK) status code is returned if a group is deleted, and
	 *         a 404 (Not Found) status code is returned if the group cannot
	 *         be found in the database. If a client is not the owner of the
	 *         group, they are restricted access using a 403 (Forbidden)
	 *         status code.
	 */
	private Response removeGroup(String authorization, String groupName) {
		authorization = authorization.substring(authorization.indexOf(" ") + 1); // remove "Bearer" from Authorization header
		try {
			Group group = groupDAO.findByName(groupName).orElseThrow(() -> new NotFoundException("No such username."));
			DecodedJWT jwt = authVerifier.verify(authorization); // verify token
			if (groupDAO.isUserOwnerOfGroup(jwt.getClaim("username").asString(), groupName)) { // if user is correct...
				groupDAO.delete(group); // delete that group of bad boiz
				return Response // return OK
						.ok(new GenericResponse(Response.Status.OK.getStatusCode(), "Deleted! Get the people back together again! :("))
						.build();

			} else { // nice try hacker, eject client
				return Response
						.status(Response.Status.FORBIDDEN)
						.entity(new GenericResponse(Response.Status.FORBIDDEN.getStatusCode(), "You are not the owner! Man, not cool!"))
						.build();
			}
		} catch (TokenExpiredException e) {
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Token expired! Log in again!"))
					.build();
		} catch (JWTVerificationException e) { // token's screwed, eject client
			return Response
					.status(Response.Status.UNAUTHORIZED)
					.entity(new GenericResponse(Response.Status.UNAUTHORIZED.getStatusCode(), "Invalid authentication scheme!"))
					.build();
		} catch (NotFoundException e) {
			return Response
					.status(Response.Status.NOT_FOUND)
					.entity(new NotFoundResponse(groupName + "could not be found! Try again!"))
					.build();
		}
	}
}
